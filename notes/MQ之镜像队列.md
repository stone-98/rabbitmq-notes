# MQ之镜像队列

如果MQ集群只有一个Broker节点，那么该节点的失效将导致整体服务的可用性。

如果RabbitMQ集群由多个Broker节点组成，那么从整体可用性来说，该集群对于单点故障是有弹性的，尽管交换机和绑定关系能够在单点故障问题上幸免于难，但是队列和在队列中的消息确不行，因为队列进程及其内容仅仅维持在单节点上，所以一个节点的失效表现为其队列不可用。

所以镜像队列机制应运而生，它是指一个队列可以拥有多个队列的镜像，队列的镜像可以存放在其他Broker节点上，如果这个队列所在的节点故障时，可以通过队列的镜像来替代这个队列。

在通常的用法中，对于一个队列，都包含一个主节点（队列）和若干个从节点（队列的镜像），相应的结构如图所示：

![image-20230722111841689](https://gitee.com/stone-98/picture-bed/raw/master/202307221118519.png)

slave会根据master执行命令的顺序依次执行对应的命令。所以slave与master上维护的状态应该是相同的。如果master因为某种原因出现故障，那么“资历最老”（根据slave加入的时间进行排序）的salve将会提升为master。

发送镜像队列的消息会被同时发送到master和slave,如果此时master挂了，消息还会在slave上。除了发送消息外所有动作都只会向master发送，再由master将命令执行的结果广播给各个slave。

例如当消费者与slave建立连接并订阅，其本质都是从master上获取消息，只不过由slave进行了一个转发的动作。

这样大家可能就想到了，这样是不是会对master有过大的读写压力，我们要知道这里的master和salve是针对于队列来说的，而队列的master还是可以均匀的分布在各个的节点上。

来举一个例子，当前RabbitMQ集群中有三个Broker节点，该集群节点中分别有3个队列Q1、Q2、Q3，他们三个队列分别有3个master节点和6个slave节点，分布图如下图所示：

![image-20230722144846310](https://gitee.com/stone-98/picture-bed/raw/master/202307221526280.png)

从上图中可知：

- Q1的负载基本上集中在Broker1中
- Q2的负载基本上集中在Broker2中
- Q3的负载基本上集中在Broker3中

上述很大一程度保证RabbitMQ的负载均衡，但是由于每个队列的负载程度不通所以也无法绝对的保持负载均衡。至于为什么不像Mysql一样进行读写分离，虽说这样是完全可以实现的，但是这样并不能进一步优化负载，反而增加系统的复杂性，显得得不偿失。

